package zero_50.dp;

/**
 * LC70
 * @Author huJesse
 * @Date 2021/12/2 17:19
 * @Key 爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
 * 那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。
 * 所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。
 * 最后爬1阶、2阶也是两种方法，为什么总方法数量不写成这样f(n) = f(n-1) + 1 + f(n-2) + 1
 *
 * 因为不是只看最后一步怎么走，也要思考中间增加的过程
 *
 * 台阶一：(1)
 * 台阶二：(1,1) 【2】
 * 台阶三：(1,1,1) (2,1) 【1,2】
 * 台阶四：(1,1,1,1) (2,1,1) (1,2,1) 【1,1,2】 【2,2】
 * 理解
 *
 * 圆括号是在上一个基础（n-1）上加1步，方括号是在上上个基础（n-2）上加2步，理解为就算加1步2步，也不会新增方法的数量，只是更新了原来的旧方法，在其基础上多走1、2步，不算两种新方法。
 * 所以最后一步看似没走，其实已经修改了旧方法里面的步数，使其可以到达第n阶台阶
 *        // int[] dp = new int[n]; // 1、确定dp数组以及下标含义 dp[i]：爬到第i层楼梯有dp[i]种方法. 下标i表示第i层楼梯、
 *         // dp[i] = dp[i-1]+dp[i-2]  2、确定状态转移方程
 *         // 首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。
 *         //
 *         //还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。
 *         //
 *         //那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！
 */
public class ClimbingStairs {
    //V1、采用深度遍历时间复杂度太高

    //v2、寻找dp规律
    public int climbStairs(int n) {
        int []dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <=n ; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[dp.length-1];
    }
}
