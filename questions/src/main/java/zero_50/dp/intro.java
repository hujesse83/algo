package zero_50.dp;

public interface intro {
    /**
     *
     * Head：什么时候用dp。即为本次结果与上次的状态有关
     * 1、确定dp数组（dp table）以及下标的含义
     * 2、确定递推公式
     * 3、dp数组如何初始化
     * 4、确定遍历顺序
     * 5、举例推导dp数组
     */

    /**
     * 重点体型：
     * 1、背包问题 -- 每个物品的数量只要一个（01）背包
     *           -- 无数个  完全背包
     *           -- 不同物品 数量不同 多重背包（leetcode上没有）
     *           -- 按组打包，每组最多选一个  分组背包
     */

    /**
     * 01背包
     *          -- 暴力回溯 O(n) = 2^n . 一个物品具有选与不选.
     *          -- 动规
     *           1、确定dp数组以及下标的含义
     *              对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
     *           2、使用一维数组
     *              意思是dp[j] = 不加入背包的价值 与 加入了背包之后 （物品的价值 + 剩余空间背包最大价值）的比较
     *              dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
     *
     *完全背包
     * 概述：有N个物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i。每件物品都有无限个（也就是可以放入背包多次）
     * 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
     * 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
     * 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
     */
}
